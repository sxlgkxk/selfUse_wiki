{% extends "layout.html" %}{% block body %}<h1><a href='/c/文章随笔/领域学习与分析/项目/短延时协议/短延时流媒体协议/基础知识'>文章随笔/领域学习与分析/项目/短延时协议/短延时流媒体协议/基础知识 </a> websocket协议 <i class='fas fa-edit btn_edit' style='color: #ddd' name='/v/文章随笔/领域学习与分析/项目/短延时协议/短延时流媒体协议/基础知识/websocket协议?action=edit' onclick='window.location.href=this.getAttribute("name")'></i></h1><hr/><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<ul>
<li>websocket协议
<ul>
<li>websocket背景知识
<ul>
<li>可在TCP上建立双向持久的连接</li>
<li>使用443和80端口, 与http类似, 可绕过防火墙</li>
<li>ws和wss(websocket secure)定义为两个新的url方案, 类似ws://site/api, wss://site/api</li>
<li>传统技术多采用轮询, 浏览器需定期不断地向服务器发送请求, 有效数据占比小</li>
<li>优点
<ul>
<li>全双工使得实时性强, 多余的控制信息变少, 建立了有状态的连接无需在请求中发送状态信息</li>
<li>更好的二进制支持</li>
</ul></li>
</ul></li>
<li>协议细节
<ul>
<li>一篇翻译过的关于协议格式的教程: https://juejin.im/post/5a05d89051882540f36305df</li>
<li>握手请求
<ul>
<li><p>客户端发出</p>
<pre><code>GET / HTTP/1.1
Upgrade: websocket
Connection: Upgrade
Host: example.com
Origin: http://example.com
Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==
Sec-WebSocket-Version: 13</code></pre></li>
<li><p>服务器回应</p>
<pre><code>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=
Sec-WebSocket-Location: ws://example.com/</code></pre></li>
<li>字段
<ul>
<li>Connection: Upgrade</li>
<li>Upgrade: websocket</li>
<li>Sec-WebSocket-Key: 随机字符串, 服务器用于构造一个SHA-1的摘要, 把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”, 然后计算SHA-1摘要, 之后进行BASE-64编码, 将结果做为“Sec-WebSocket-Accept”头的值, 返回给客户端</li>
<li>Sec-WebSocket-Version: 13</li>
<li>Origin: 类似于Referer, 但只包含协议和主机名</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>客户端例程</p>
<pre><code>var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);

ws.onopen = function(evt) { 
  console.log(&quot;Connection open ...&quot;); 
  ws.send(&quot;Hello WebSockets!&quot;);
};

ws.onmessage = function(evt) {
  console.log( &quot;Received Message: &quot; + evt.data);
  ws.close();
};

ws.onclose = function(evt) {
  console.log(&quot;Connection closed.&quot;);
};      </code></pre>
<ul>
<li>建立的WebSocket对象的方法与属性
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket">文档</a></li>
<li><strong>init</strong>(url,[protocol]), 第二个参数为可选的指定子协议</li>
<li>readyState: int. CONNECTING, OPEN, CLOSING, CLOSED</li>
<li>onopen: func()</li>
<li>onclose: func(event)
<ul>
<li>event属性: code, reason, wasClean</li>
</ul></li>
<li>onmessage: func(event)
<ul>
<li>event属性: data(类型为blob或ArrayBuffer)</li>
</ul></li>
<li>binaryType: 指定接收类型('arraybuffer','blob')</li>
<li>bufferedAmount: int, 还有多少数据未发送, ==0表示结束</li>
<li>onerror: func(event)</li>
<li>.send('str')</li>
</ul></li>
</ul></li>
<li>服务器端实现
<ul>
<li>µWebSockets</li>
<li>Socket.IO</li>
<li>WebSocket-Node</li>
<li>Websocketd: 类似于http-server, 快速搭建
<ul>
<li>服务端
<ul>
<li>bash: 简易echo ``` #!/bin/bash</li>
</ul>
<p>echo 1 sleep 1</p>
<p>echo 2 sleep 1</p>
<p>echo 3</p>
<pre><code></code></pre>
<p>websocketd --port=8080 ./ba.sh <code>- node     - 简易echo</code> process.stdin.setEncoding('utf8');</p>
<pre><code>process.stdin.on(&#39;readable&#39;, function() {
  var chunk = process.stdin.read();
  if (chunk !== null) {
    process.stdout.write(&#39;data: &#39; + chunk);
  }
});
```
- 多人聊天室
```
#!/bin/bash

echo &quot;Please enter your name:&quot;; read USER
echo &quot;[$(date)] ${USER} joined the chat&quot; &gt;&gt; chat.log
echo &quot;[$(date)] Welcome to the chat ${USER}!&quot;
tail -n 0 -f chat.log --pid=$$ | grep --line-buffered -v &quot;] ${USER}&gt;&quot; &amp;
while read MSG; do echo &quot;[$(date)] ${USER}&gt; ${MSG}&quot; &gt;&gt; chat.log; done
```</code></pre></li>
</ul></li>
</ul></li>
<li>语言选择
<ul>
<li>python3
<ul>
<li>案例, 建立socket, 自己解析报文: https://www.cnblogs.com/JetpropelledSnake/p/9033064.html</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</body>
</html>{% endblock %}