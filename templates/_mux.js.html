{% extends "layout.html" %}{% block body %}<h1><a href='/c/文章随笔/领域学习与分析/项目/短延时协议/短延时流媒体协议/开发工具文档'>文章随笔/领域学习与分析/项目/短延时协议/短延时流媒体协议/开发工具文档 </a> mux.js <i class='fas fa-edit btn_edit' style='color: #ddd' name='/v/文章随笔/领域学习与分析/项目/短延时协议/短延时流媒体协议/开发工具文档/mux.js?action=edit' onclick='window.location.href=this.getAttribute("name")'></i></h1><hr/><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<ul>
<li>videojs/mux.js
<ul>
<li>词汇
<ul>
<li>utility: 工具库, 和module类似</li>
<li>box: fMP4拆分成的小片段(更小划分)</li>
<li>segment: 由box组成, 是比box略大一级的划分</li>
<li>Transmuxer</li>
<li>supplementary: 补充信息</li>
</ul></li>
<li>轻型的js库, 用于操纵video标签</li>
<li>fMP4
<ul>
<li>ISOBMFF规定</li>
<li>由不同的box组成
<ul>
<li>ftyp (File Type Box)</li>
<li>moov (Movie Header Box)</li>
<li>moof (Movie Fragment Box)</li>
<li>mdat (Movie Data Box)</li>
</ul></li>
<li>每个fMP4的第一个segment需要以包含ftyp和moov的box开始, 并且跟着moof和mdat的box对, 这样的第一个segment叫做init segment, 包含moof和mdat的指向媒体信息的segment叫做media segment</li>
</ul></li>
<li>下载
<ul>
<li><code>npm install --save mux.js</code></li>
<li>https://github.com/videojs/mux.js/releases/latest/download/mux.js</li>
</ul></li>
<li>使用
<ul>
<li>服务器端
<ul>
<li>node
<ul>
<li>require()</li>
<li>muxjs模块
<ul>
<li>codecs: 处理编码</li>
<li>mp4: 传输fMP4的box</li>
<li>flv: 传输flash</li>
<li>mp2t: 传输MPEG2内容</li>
</ul></li>
</ul></li>
</ul></li>
<li>使用Transmuxer, 将数据推至transmuxer, 输入Uint8Array数组格式的MEPG-2流, 得到片段mp4</li>
<li>将fMP4推流转换至MSE buffer的例程
<ul>
<li><a href="https://github.com/videojs/mux.js#basic-usage">link</a>
<ul>
<li><p>服务器端程序</p>
<pre><code>// Create your transmuxer:
//  initOptions is optional and can be omitted at this time.
var transmuxer = new muxjs.mp4.Transmuxer(initOptions);

// Create an event listener which will be triggered after the transmuxer processes data:
//  &#39;data&#39; events signal a new fMP4 segment is ready
transmuxer.on(&#39;data&#39;, function (segment) {
  // This code will be executed when the event listener is triggered by a Transmuxer.push() method execution.
  // Create an empty Uint8Array with the summed value of both the initSegment and data byteLength properties.
  let data = new Uint8Array(segment.initSegment.byteLength + segment.data.byteLength);

  // Add the segment.initSegment (ftyp/moov) starting at position 0
  data.set(segment.initSegment, 0);

  // Add the segment.data (moof/mdat) starting after the initSegment
  data.set(segment.data, segment.initSegment.byteLength);

  // Uncomment this line below to see the structure of your new fMP4
  // console.log(muxjs.mp4.tools.inspect(data));

  // Add your brand new fMP4 segment to your MSE Source Buffer
  sourceBuffer.appendBuffer(data);
});

// When you push your starting MPEG-TS segment it will cause the &#39;data&#39; event listener above to run.
// It is important to push after your event listener has been defined.
transmuxer.push(transportStreamSegment);
transmuxer.flush();</code></pre></li>
<li><p>客户端: <a href="file:///home/gkxk/repo/work/muxjs/index.html">link</a></p>
<pre><code>  &lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Basic Transmuxer Test&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;video controls width=&quot;80%&quot;&gt;&lt;/video&gt;
    &lt;script src=&quot;https://github.com/videojs/mux.js/releases/latest/download/mux.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      // Create array of TS files to play
      segments = [
        &quot;segment-0.ts&quot;,
        &quot;segment-1.ts&quot;,
        &quot;segment-2.ts&quot;,
      ];

      // Replace this value with your files codec info
      mime = &#39;video/mp4; codecs=&quot;mp4a.40.2,avc1.64001f&quot;&#39;;

      let mediaSource = new MediaSource();
      let transmuxer = new muxjs.mp4.Transmuxer();

      video = document.querySelector(&#39;video&#39;);
      video.src = URL.createObjectURL(mediaSource);
      mediaSource.addEventListener(&quot;sourceopen&quot;, appendFirstSegment);

      function appendFirstSegment(){
        if (segments.length == 0){
          return;
        }

        URL.revokeObjectURL(video.src);
        sourceBuffer = mediaSource.addSourceBuffer(mime);
        sourceBuffer.addEventListener(&#39;updateend&#39;, appendNextSegment);

        transmuxer.on(&#39;data&#39;, (segment) =&gt; {
          let data = new Uint8Array(segment.initSegment.byteLength + segment.data.byteLength);
          data.set(segment.initSegment, 0);
          data.set(segment.data, segment.initSegment.byteLength);
          console.log(muxjs.mp4.tools.inspect(data));
          sourceBuffer.appendBuffer(data);
        })

        fetch(segments.shift()).then((response)=&gt;{
          return response.arrayBuffer();
        }).then((response)=&gt;{
          transmuxer.push(new Uint8Array(response));
          transmuxer.flush();
        })
      }

      function appendNextSegment(){
        // reset the &#39;data&#39; event listener to just append (moof/mdat) boxes to the Source Buffer
        transmuxer.off(&#39;data&#39;);
        transmuxer.on(&#39;data&#39;, (segment) =&gt;{
          sourceBuffer.appendBuffer(new Uint8Array(segment.data));
        })

        if (segments.length == 0){
          // notify MSE that we have no more segments to append.
          mediaSource.endOfStream();
        }

        segments.forEach((segment) =&gt; {
          // fetch the next segment from the segments array and pass it into the transmuxer.push method
          fetch(segments.shift()).then((response)=&gt;{
            return response.arrayBuffer();
          }).then((response)=&gt;{
            transmuxer.push(new Uint8Array(response));
            transmuxer.flush();
          })
        })
      }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre></li>
<li><p>补充信息的传输</p>
<pre><code>transmuxer.on(&#39;data&#39;, function (segment) {
  // create a metadata text track cue for each ID3 frame:
  segment.metadata.frames.forEach(function(frame) {
    metadataTextTrack.addCue(new VTTCue(time, time, frame.value));
  });
  // create a VTTCue for all the parsed CEA-608 captions:&gt;
  segment.captions.forEach(function(cue) {
    captionTextTrack.addCue(new VTTCue(cue.startTime, cue.endTime, cue.text));
  });
});</code></pre></li>
<li><p>mp4处理</p>
<pre><code>// drop in a Uint8Array of an MP4:
var parsed = muxjs.mp4.tools.inspect(bytes);
// dig into the boxes:
console.log(&#39;The major brand of the first box:&#39;, parsed[0].majorBrand);
// print out the structure of the MP4:
document.body.appendChild(document.createTextNode(muxjs.textifyMp4(parsed)));</code></pre></li>
<li><a href="https://github.com/videojs/mux.js/blob/master/docs/test-content.md">创建fMP4测试视频文件</a>
<ul>
<li>ffmpeg
<ul>
<li>生成纯色背景的视频</li>
<li>控制音频</li>
<li>控制字幕</li>
</ul></li>
<li>bento4
<ul>
<li><a href="https://www.bento4.com/downloads/">官网</a></li>
<li>生成init segment和media sesgment</li>
<li>创建DASH manifest</li>
</ul></li>
</ul></li>
<li>代码注释
<ul>
<li>客户端
<ul>
<li>引入script</li>
<li>指定播放的一个数组的ts包(一系列segment)</li>
<li>指定编码类型: video/mp4; codecs=&quot;mp4a.40.2,avc1.64001f&quot;</li>
<li>新建mediaSource=MediaSource()</li>
<li>新建transmuxer=muxjs.mp4.Transmuxer() - ---</li>
<li>选定video标签</li>
<li>设定video的src属性为URL.createObjectURL(mediaSource) - ---</li>
<li>mediaSource的sourceopen事件设为appendFirstSegment()</li>
<li>声明appendFirstSegment函数
<ul>
<li>根据segments的长度做出判断</li>
<li><code>重唤起url?</code>: URL.revokeObjectURL(video.src)</li>
<li>新建sourceBuffer为mediaSource.addSourceBuffer(编码格式)</li>
<li>为sourceBuffer添加监听updateend为appendNextSegment()</li>
<li>为transmuxer添加监听data, 对segment进行处理
<ul>
<li>将data设置长度为segment的initSegment的字节长度+segment的data的字节长度</li>
<li>data.set(设置segment的初始片段为,0)</li>
<li>data.set(设置segment.data为, segment初始片段的字节 长度)</li>
<li>sourceBuffer.appendBuffer(添加data)</li>
</ul></li>
<li>执行一系列通信
<ul>
<li>fetch取得segments.shift()</li>
<li>取得response的arrayBuffer()</li>
<li>对于response', 向transmuxer推送新建的Uint8Array(response)</li>
<li>transmuxer.flush()对transmuxer进行刷新</li>
</ul></li>
</ul></li>
<li>生明appendNextSegment()
<ul>
<li>transmuxer.off('data')取消原监听函数</li>
<li>transmuxer添加新的data监听:
<ul>
<li>为sourceBuffer添加Buffer为当前获取segment的data</li>
</ul></li>
<li>如果segments长度检测为0
<ul>
<li>mediaSource.endOfStream()关闭流</li>
</ul></li>
<li>对于segments中的每一个segment, 获取并将其填充到transmuxer中</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</body>
</html>{% endblock %}