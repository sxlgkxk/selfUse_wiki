{% extends "layout.html" %}{% block body %}<h1><a href='/c/wiki/tech/linux技术/shell'>wiki/tech/linux技术/shell </a> nvim_plugin </h1><hr/><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#vim-插件开发指南">Vim 插件开发指南</a><ul>
<li><a href="#简介">简介</a></li>
<li><a href="#基本语法">基本语法</a><ul>
<li><a href="#注释">注释</a></li>
<li><a href="#变量">变量</a></li>
<li><a href="#作用域">作用域</a></li>
</ul></li>
<li><a href="#vim-插件的项目结构">Vim 插件的项目结构</a></li>
<li><a href="#vim-自定义命令">Vim 自定义命令</a></li>
<li><a href="#推荐阅读">推荐阅读</a></li>
</ul></li>
</ul>
</div>
<h1 id="vim-插件开发指南">Vim 插件开发指南</h1>
<!-- vim-markdown-toc GFM -->
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#基本语法">基本语法</a></li>
<li><a href="#注释">注释</a></li>
<li><a href="#变量">变量</a></li>
<li><a href="#作用域">作用域</a></li>
<li><a href="#vim-插件的项目结构">Vim 插件的项目结构</a></li>
<li><a href="#vim-自定义命令">Vim 自定义命令</a></li>
<li><a href="#推荐阅读">推荐阅读</a></li>
</ul>
<!-- vim-markdown-toc -->
<h2 id="简介">简介</h2>
<p>Vim 插件开发中文指南，主要包括 Vim 脚本语法、插件开发技巧等。</p>
<h2 id="基本语法">基本语法</h2>
<h3 id="注释">注释</h3>
<p>在写脚本时，经常需要在源码里面添加一些注释信息，辅助阅读源码，Vim 脚本注释比较简单，是以 <code>&quot;</code> 开头的，只存在行注释，不存在块注释。因此，对于多行注释，需要再每行开头添加 <code>&quot;</code>。</p>
<p>示例：</p>
<pre class="vim"><code>&quot; 这是一行注释，
let g:helloworld = 1  &quot; 这是在行尾注释</code></pre>
<h3 id="变量">变量</h3>
<p>在 Vim 脚本里，可以使用关键字 <code>let</code> 来申明变量，最基本的方式为：</p>
<pre class="vim"><code>&quot; 定义一个类型是字符串的变量 g:helloworld
let g:helloworl = &quot;sss&quot;</code></pre>
<p>前面的例子中，是定义一个字符串，Vim 脚本中支持以下几种数据类型：</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>ID</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Number</td>
<td>0</td>
<td>整数</td>
</tr>
<tr class="even">
<td>String</td>
<td>1</td>
<td>字符串</td>
</tr>
<tr class="odd">
<td>Funcref</td>
<td>2</td>
<td>函数指针</td>
</tr>
<tr class="even">
<td>List</td>
<td>3</td>
<td>列表</td>
</tr>
<tr class="odd">
<td>Dictionary</td>
<td>4</td>
<td>字典</td>
</tr>
<tr class="even">
<td>Float</td>
<td>5</td>
<td>浮点数</td>
</tr>
<tr class="odd">
<td>Boolean</td>
<td>6</td>
<td></td>
</tr>
<tr class="even">
<td>None</td>
<td>7</td>
<td></td>
</tr>
<tr class="odd">
<td>Job</td>
<td>8</td>
<td></td>
</tr>
<tr class="even">
<td>Channel</td>
<td>9</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="作用域">作用域</h3>
<p>Vim 变量存在三种作用域，全局变量、局部变量、和脚本变量。通常，我们以不同的前缀来区别作用域，比如使用 <code>g:</code> 表示全局变量，<code>s:</code> 表示脚本变量。 在一些特殊情况下，前缀是可以省略的，Vim 会为该变量选择默认的作用域。不同的情况下，默认的作用域是不一样的，在函数内部，默认作用域是局部变量， 而在函数外部，默认作用域是全局变量：</p>
<pre class="vim"><code>let g:helloworld = 1  &quot; 这是一个全局变量， g: 前缀未省略
let helloworld = 1    &quot; 这也是一个全局变量，在函数外部，默认的作用域是全局的

function! HelloWorld()
  let g:helloworld = 1    &quot; 这是函数内部全局变量
  let helloworld = 1      &quot; 这是一个函数内部的局部变量，在函数内部，默认的作用域为局部变量
endfunction</code></pre>
<table>
<thead>
<tr class="header">
<th>前缀</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>g:</code></td>
<td>全局变量</td>
</tr>
<tr class="even">
<td><code>l:</code></td>
<td>局部变量，只可在函数内部使用</td>
</tr>
<tr class="odd">
<td><code>s:</code></td>
<td>脚本变量，只可以在当前脚本函数内使用</td>
</tr>
<tr class="even">
<td><code>v:</code></td>
<td>Vim 特殊变量</td>
</tr>
<tr class="odd">
<td><code>b:</code></td>
<td>作用域限定在某一个缓冲区内</td>
</tr>
<tr class="even">
<td><code>w:</code></td>
<td>作用域限定在窗口内部</td>
</tr>
<tr class="odd">
<td><code>t:</code></td>
<td>作用域限定在标签内部</td>
</tr>
</tbody>
</table>
<p>此外，在开发 Vim 插件之前，你还需要了解 vimrc 和 Vim 插件的区别。</p>
<h2 id="vim-插件的项目结构">Vim 插件的项目结构</h2>
<p>在开发 Vim 插件之前，需要了解一下，一个 Vim 插件项目的目录结构是怎样的，以及每一个目录里文件的意义是什么。 Vim 插件标准的目录结构为：</p>
<pre class="text"><code>autoload/               自动载入脚本
colors/                 颜色主题
plugin/                 在 Vim 启动时将被载入的脚本
ftdetect/               文件类型识别脚本
syntax/                 语法高亮文件
ftplugin/               文件类型相关插件
compiler/                 编译器
indent/                 语法对齐</code></pre>
<p>下面，我们来逐一说明下每一个目录的用途：</p>
<p><strong>autoload/</strong></p>
<p>顾名思义，该文件夹下的脚本会在特点条件下自动被载入。这里的特定条件指的是当某一个 autoload 类型的函数被调用，并且 Vim 当前环境下并未定义该函数时。 比如调用 <code>call helloworld#init()</code> 时，Vim 会先检测当前环境下是否定义了该函数，若没有，则在 <code>autoload/</code> 目录下找 <code>helloworld.vim</code> 这一文件， 并将其载入，载入完成后执行 <code>call helloworld#init()</code>.</p>
<p><strong>plugin/</strong></p>
<p>该目录里的文件将在 Vim 启动时被运行，作为一个优秀的 Vim 插件，应当尽量该目录下的脚本内容。通常，可以将插件的快捷键、命令的定义保留在这个文件里。</p>
<p><strong>ftdetect/</strong></p>
<p>ftdetect 目录里通常存放的是文件类型检测脚本，该目录下的文件也是在 Vim 启动时被载入的。在这一目录里的文件内容，通常比较简单，比如：</p>
<pre class="vim"><code>autocmd BufNewFile,BufRead *.helloworld set filetype=helloworld</code></pre>
<p>以上脚本使得 Vim 在打开以 <code>.helloworld</code> 为后缀的文件时，将文件类型设置为 <code>helloworld</code>。通常，这个脚本的文件名是和所需要设置的文件类型一样的，上面的例子中文件的名称就是 <code>helloworld.vim</code>。</p>
<p><strong>syntax/</strong></p>
<p>这一目录下的文件，主要是定义语法高亮的。通常文件名前缀和对应的语言类型相同，比如 Java 的语法文件文件名为 <code>java.vim</code>。 关于如何写语法文件，将在后面详细介绍。</p>
<p><strong>colors/</strong></p>
<p>colors 目录下主要存储一些颜色主题脚本，当执行 <code>:colorscheme + 主题名</code> 命令时，对应的颜色主题脚本将被载入。比如执行 <code>:colorscheme helloworld</code> 时，<code>colors/helloworld.vim</code> 这一脚本将被载入。</p>
<p><strong>compiler/</strong></p>
<p>这一名录里是一些预设的编译器参数，主要给 <code>:make</code> 命令使用的。在最新版的 Vim 中可以使用 <code>:compiler! 编译器名</code> 来为当前缓冲区设定编译器。比如当执行 <code>:compiler! helloworld</code> 时，<code>compiler/helloworld.vim</code> 这一脚本将被载入。</p>
<p><strong>indent/</strong></p>
<p>在 indent 目录里，主要是一些语法对齐相关的脚本。</p>
<h2 id="vim-自定义命令">Vim 自定义命令</h2>
<p>Vim 的自定义命令可以通过 <code>command</code> 命令来定义，比如：</p>
<pre class="vim"><code>command! -nargs=* -complete=custom,helloworld#complete HelloWorld call helloworld#test()</code></pre>
<p>紧接 <code>command</code> 命令其后的 <code>!</code> 表示强制定义该命令，即使前面已经定义过了同样名称的命令，也将其覆盖掉。 <code>-nargs=*</code> 表示，该命令可接受任意个数的参数， 包括 0 个。<code>-nargs</code> 的取值有以下几种情况：</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-nargs=0</code></td>
<td>不接受任何参数（默认）</td>
</tr>
<tr class="even">
<td><code>-nagrs=1</code></td>
<td>只接受一个参数</td>
</tr>
<tr class="odd">
<td><code>-nargs=*</code></td>
<td>可接收任意个数参数</td>
</tr>
<tr class="even">
<td><code>-nargs=?</code></td>
<td>可接受 1 个或者 0 个参数</td>
</tr>
<tr class="odd">
<td><code>-nargs=+</code></td>
<td>至少提供一个参数</td>
</tr>
</tbody>
</table>
<p><code>-complete=custom,helloworld#complete</code> 表示，改命令的补全方式采用的是自定义函数 <code>helloworld#complete</code>。<code>-complete</code> 可以接受的参数包括如下内容：</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-complete=augroup</code></td>
<td>autocmd 组名</td>
</tr>
<tr class="even">
<td><code>-complete=buffer</code></td>
<td>buffer 名称</td>
</tr>
<tr class="odd">
<td><code>-complete=behave</code></td>
<td><code>:behave</code> 命令子选项</td>
</tr>
<tr class="even">
<td><code>-complete=color</code></td>
<td>颜色主题</td>
</tr>
<tr class="odd">
<td><code>-complete=command</code></td>
<td>Ex 命令及参数</td>
</tr>
<tr class="even">
<td><code>-complete=compiler</code></td>
<td>编译器</td>
</tr>
<tr class="odd">
<td><code>-complete=cscope</code></td>
<td><code>:cscope</code> 命令子选项</td>
</tr>
<tr class="even">
<td><code>-complete=dir</code></td>
<td>文件夹名称</td>
</tr>
<tr class="odd">
<td><code>-complete=environment</code></td>
<td>环境变量名称</td>
</tr>
<tr class="even">
<td><code>-complete=event</code></td>
<td>自动命令的事件名称</td>
</tr>
<tr class="odd">
<td><code>-complete=expression</code></td>
<td>Vim 表达式</td>
</tr>
<tr class="even">
<td><code>-complete=file</code></td>
<td>文件及文件夹名称</td>
</tr>
<tr class="odd">
<td><code>-complete=file_in_path</code></td>
<td><code>path</code> 选项里的文件及文件夹名称</td>
</tr>
<tr class="even">
<td><code>-complete=filetype</code></td>
<td>文件类型</td>
</tr>
<tr class="odd">
<td><code>-complete=function</code></td>
<td>函数名称</td>
</tr>
<tr class="even">
<td><code>-complete=help</code></td>
<td>帮助命令子选项</td>
</tr>
<tr class="odd">
<td><code>-complete=highlight</code></td>
<td>高亮组名称</td>
</tr>
<tr class="even">
<td><code>-complete=history</code></td>
<td><code>:history</code> 子选项</td>
</tr>
<tr class="odd">
<td><code>-complete=locale</code></td>
<td>locale 名称（相当于命令 <code>locale -a</code> 的输出）</td>
</tr>
<tr class="even">
<td><code>-complete=mapping</code></td>
<td>快捷键名称</td>
</tr>
<tr class="odd">
<td><code>-complete=menu</code></td>
<td>目录</td>
</tr>
<tr class="even">
<td><code>-complete=messages</code></td>
<td><code>:messages</code> 命令子选项</td>
</tr>
<tr class="odd">
<td><code>-complete=option</code></td>
<td>Vim 选项名称</td>
</tr>
<tr class="even">
<td><code>-complete=packadd</code></td>
<td>可选的插件名称补全</td>
</tr>
<tr class="odd">
<td><code>-complete=shellcmd</code></td>
<td>shell 命令补全</td>
</tr>
<tr class="even">
<td><code>-complete=sign</code></td>
<td><code>:sign</code> 命令补全</td>
</tr>
<tr class="odd">
<td><code>-complete=syntax</code></td>
<td>语法文件名称补全</td>
</tr>
<tr class="even">
<td><code>-complete=syntime</code></td>
<td><code>:syntime</code> 命令补全</td>
</tr>
<tr class="odd">
<td><code>-complete=tag</code></td>
<td>tags</td>
</tr>
<tr class="even">
<td><code>-complete=tag_listfiles</code></td>
<td>tags, file names are shown when CTRL-D is hit</td>
</tr>
<tr class="odd">
<td><code>-complete=user</code></td>
<td>user names</td>
</tr>
<tr class="even">
<td><code>-complete=var</code></td>
<td>user variables</td>
</tr>
<tr class="odd">
<td><code>-complete=custom,{func}</code></td>
<td>custom completion, defined via {func}</td>
</tr>
<tr class="even">
<td><code>-complete=customlist,{func}</code></td>
<td>custom completion, defined via {func}</td>
</tr>
</tbody>
</table>
<p>这里主要解释一些自定义的补全函数，从上面的表格可以看出，有两种定义自定义命令补全函数的方式。 <code>-complete=custom,{func}</code> 和 <code>-complete=customlist,{func}</code>。这两种区别在与函数的返回值， 前者要求是一个 <code>string</code> 而后者要求补全函数的返回值是 <code>list</code>. 自定义命令补全函数接受三个参数。</p>
<pre class="vim"><code>:function {func}(ArgLead, CmdLine, CursorPos)</code></pre>
<p>我们以实际的例子来解释这三个参数的含义，比如在命令行是如下内容时，<code>|</code> 表示光标位置，我按下了 <code>&lt;Tab&gt;</code> 键调用了补全函数，那么传递给补全函数的三个参数分别是：</p>
<pre class="vim"><code>:HelloWorld hello|</code></pre>
<table>
<thead>
<tr class="header">
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ArgLead</code></td>
<td>当前需要补全的部分，通常是光标前的字符串，上面的例子中是指 <code>hello</code></td>
</tr>
<tr class="even">
<td><code>CmdLine</code></td>
<td>指的是整个命令行内的内容，此时是 <code>HelloWorld hello</code></td>
</tr>
<tr class="odd">
<td><code>CursorPos</code></td>
<td>指的当前光标所在的位置，此时是 16, 即为 <code>len('HelloWorld hello')</code></td>
</tr>
</tbody>
</table>
<p>下面，我们来看下定义的函数具体内容：</p>
<pre class="vim"><code>function! helloworld#complete(ArgLead, CmdLine, CursorPos) abort
    return join([&#39;hellolily&#39;, &#39;hellojeky&#39;, &#39;hellofoo&#39;, &#39;world&#39;]
            \ &quot;\n&quot;)
endfunction</code></pre>
<p>在上面的函数里，返回的实际上是一个有四行的字符串，Vim 会自动根据 <code>ArgLead</code> 来筛选出可以用来补全的选项，并展示在状态栏上。 此时，四行里最后一个 <code>world</code> 因为开头不匹配 <code>ArgLead</code> 所以不会被展示在状态栏上，因此补全效果只有三个可选项。</p>
<div class="figure">
<img src="https://user-images.githubusercontent.com/13142418/44915590-f2b43a80-ad65-11e8-92aa-0f4eac3a0a26.gif" alt="command-complete" />
<p class="caption">command-complete</p>
</div>
<p><code>-complete=customlist,{func}</code> 这一参数所对应的补全函数，也是接受相同的三个参数，但该函数返回的是一个 list。</p>
<p>下面，我们来测试这个函数：</p>
<pre class="vim"><code>function! helloworld#complete(ArgLead, CmdLine, CursorPos) abort
    return [&#39;hellolily&#39;, &#39;hellojeky&#39;, &#39;hellofoo&#39;, &#39;world&#39;]
endfunction</code></pre>
<div class="figure">
<img src="https://user-images.githubusercontent.com/13142418/44916266-e03b0080-ad67-11e8-9cb8-535a970768e4.gif" alt="command-complete" />
<p class="caption">command-complete</p>
</div>
<p>区别很明显，<code>customlist</code> 补全时不会自动根据 <code>ArgLead</code> 进行筛选，并且直接补全整个返回的 list，即使列表中有一个 <code>world</code> 完全与 <code>ArgLead(hello)</code> 不同， 也会将其直接覆盖。因此，当使用 <code>customlist</code> 时，需要在函数内根据 <code>ArgLead</code> 进行筛选，将函数该为如下，就可以得到相同效果了：</p>
<pre class="vim"><code>function! helloworld#complete(ArgLead, CmdLine, CursorPos) abort
    return filter([&#39;hellolily&#39;, &#39;hellojeky&#39;, &#39;hellofoo&#39;, &#39;world&#39;], &#39;v:val =~ &quot;^&quot; . a:ArgLead&#39;)
endfunction</code></pre>
<ul>
<li><code>-bang</code> 参数：</li>
</ul>
<p>在定义 Vim 自定义命令时，可以通过 <code>-bang</code> 参数来申明这个命令接受感叹号。比如 <code>:q</code> 与 <code>:q!</code>。 下面是一个实例：</p>
<pre class="vim"><code>fu! s:hello(bang)
  if a:bang
    echom &quot;带有叹号&quot;
  else
    echom &quot;不带有叹号&quot;
  endif
endf
command! -bang Hello call s:hello(&lt;bang&gt;0)</code></pre>
<p>在上面的实例里，函数的参数写法为 <code>&lt;bang&gt;0</code>, 当执行<code>:Hello!</code> 时，传递给 <code>s:hello</code> 这一函数的参数是 <code>!0</code> 即为 <code>1</code>，因此，此时看到打印了”带有叹号“。</p>
<p>其实除了写成 <code>&lt;bang&gt;0</code>, 还可以写 <code>&lt;bang&gt;1</code>, 甚至是 <code>&lt;bang&gt;</code> + 一个全局变量。比如：</p>
<pre class="vim"><code>let g:hello = 0
fu! s:hello(bang)
  if a:bang
    echom &quot;带有叹号&quot;
  else
    echom &quot;不带有叹号&quot;
  endif
endf
command! -bang Hello call s:hello(&lt;bang&gt;g:hello)</code></pre>
<h2 id="推荐阅读">推荐阅读</h2>
<ul>
<li><a href="https://github.com/wsdjeg/vim-galore-zh_cn">Vim 中文简明使用教程</a></li>
<li><a href="https://github.com/lymslive/vimllearn">Vim 脚本语法指北</a></li>
</ul>
</body>
</html>{% endblock %}